# 关于Hyperledger/fabric运行架构的一些分享
>>​	

​    fabric1.4的整个运行架构是从客户端向背书策略中的组织的背书节点提交交易提案开始；指定的背书节点接收到了交易提案后；连接容器模块，看是否有容器正在运行提交的交易提案指定的链码，如果有，直接将提交的交易提案的请求提交给容器中的链码，如果没有容器在运行交易提案的指定链码，那么背书节点会启动一个docker容器去运行该交易提案指定的链码；运行起来后，再将交易提案中的请求提交到容器中，经过链码处理之后，返回执行结果，在将背书的执行结果返回给客户端之前，系统链码ESCC会引导背书节点对执行结果进行背书签名，然后将执行结果以及背书签名一同返回给客户端，客户端收集到了足够多的背书结果，如果一大部分中的执行结果均为正常的返回结果，那么客户端就会把执行结果以及背书签名还有自己的签名一同提交到orderer节点进行排序。

orderer节点中的函数broadcast是对rpc服务封装后的接口，orderer节点就是通过broadcast函数去接收客户端传来的交易；在将交易提交给kafak集群前，orderer节点会对客户端的身份进行验证，当确定客户端已经向网络中指定CA申请到合法的身份证书时；orderer节点这时作为一个生产者(基于kafka架构来说是生产者)将交易提交给kafka集群中；这时，orderer节点需要向zookeeper集群获取到与自己相关的topic以及具体的partition，然后交易进入到以有序的状态进入到partition中；这时由zookeeper集群中的某一台broker去记录交易的setoff(偏移量)；再由orderer节点充当消费者（基于kafka架构来说是消费者）根据zookeeper集群提供的信息找到相关的交易，接着对交易进行过滤判断；交易在orderer节点中都是以envelope的形式存在，envelope的意思是信封的意思，表示在orderer节点交易里面的具体内容是不会进行校验的，除了配置交易；orderer只是对交易的格式进行一些简单的校验，根据定义的交易数量、交易接收超时的时间以及区块的大小对交易队列中的交易进行交易切割，也就是生成区块，并将生成的区块保存在orderer节点的本地；最后通过deliver函数，将本地的区块循环地传递给各个组织的leader节点；leader节点收到区块后，将区块传递给committer节点进行校验；committer节点通过系统链码VSCC、MVCC对区块中的交易进行校验；区块的整个结构分为三个部分，第一部分是BlockChain Header，包括区块号、前区块的hash以及本区块的hash;第二部分是data，包含了这一区块中的所有交易；最后一部分是metaInfo(元数据)，这一部分一共可以分为四块，第一块是区块的签名，第二块是区块过滤器，这一块包含的就是区块中每笔交易的标签，从标签可以看出这笔交易是否有效，在fabric底层一共定义了20多种标签来表明交易是否有效，只有1种是标记交易有效的标签，其他的都是标记交易无效的标签，至于为什么有20多种无效标签，是因为交易在不同的过滤条件下失效的标签是不同的；第三块是最新的配置区块的区块号，当有新的配置交易传递给orderer时，orderer会对其做单独成块处理，并将此区块的区块号更新到区块元数据的最新配置区块号中；最后一块就是orderer的配置。在committer节点处系统链MCVV主要是针对每个交易的标签对其进行校验，每笔交易的过滤还包括读写集的校验，即将交易版本号与世界状态版本号做出比较，以此解决双花问题；经过过滤之后，交易无论是否有效，都会被记录到账本中，但是无效的交易不会被更新到世界状态的数据库中。